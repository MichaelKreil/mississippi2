<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>readme</title></head><body><article class="markdown-body"><h1 id="mississippi2"><a name="user-content-mississippi2" href="#mississippi2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>mississippi2</h1>
<p>This module was inspired from <a href="https://github.com/maxogden/mississippi">mississippi</a>.</p>
<h2 id="usage"><a name="user-content-usage" href="#usage" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>usage</h2>
<pre><code class="bash">npm install mississippi2 --save
</code></pre>

<pre><code class="js">var miss = require('mississippi2')
</code></pre>

<h2 id="methods"><a name="user-content-methods" href="#methods" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>methods</h2>
<ul>
<li><a href="#pipe">pipe</a></li>
<li><a href="#merge">merge</a> *</li>
<li><a href="#condition">condition</a> *</li>
<li><a href="#each">each</a></li>
<li><a href="#map">map</a> *</li>
<li><a href="#filter">filter</a> *</li>
<li><a href="#reduce">reduce</a> *</li>
<li><a href="#split">split</a> *</li>
<li><a href="#spy">spy</a> *</li>
<li><a href="#pipeline">pipeline</a></li>
<li><a href="#duplex">duplex</a></li>
<li><a href="#through">through</a></li>
<li><a href="#from">from</a></li>
<li><a href="#fromString">fromValue</a> *</li>
<li><a href="#fromArray">fromArray</a> *</li>
<li><a href="#fromPromise">fromPromise</a> *</li>
<li><a href="#to">to</a></li>
<li><a href="#toString">toString</a> *</li>
<li><a href="#toArray">toArray</a> *</li>
<li><a href="#toPromise">toPromise</a> *</li>
<li><a href="#concat">concat</a></li>
<li><a href="#unique">unique</a> *</li>
<li><a href="#toJSON">toJSON</a> *</li>
<li><a href="#stringify">stringify</a> *</li>
<li><a href="#child">child</a> *</li>
<li><a href="#finished">finished</a></li>
</ul>
<h3 id="pipe"><a name="user-content-pipe" href="#pipe" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>pipe</h3>
<h5 id="misspipestream1-stream2-stream3-cb"><code>miss.pipe(stream1, stream2, stream3, ..., cb)</code></h5>
<p>Pipes streams together and destroys all of them if one of them closes. Calls <code>cb</code> with <code>(error)</code> if there was an error in any of the streams.</p>
<p>When using standard <code>source.pipe(destination)</code> the source will <em>not</em> be destroyed if the destination emits close or error. You are also not able to provide a callback to tell when the pipe has finished.</p>
<p><code>miss.pipe</code> does these two things for you, ensuring you handle stream errors 100% of the time (unhandled errors are probably the most common bug in most node streams code)</p>
<h4 id="original-module"><a name="user-content-original-module" href="#original-module" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.pipe</code> is provided by <a href="https://npmjs.org/pump"><code>require('pump')</code></a></p>
<h4 id="example"><a name="user-content-example" href="#example" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">// lets do a simple file copy
var fs = require('fs')

var read = fs.createReadStream('./original.zip')
var write = fs.createWriteStream('./copy.zip')

// use miss.pipe instead of read.pipe(write)
miss.pipe(read, write, function (err) {
  if (err) return console.error('Copy error!', err)
  console.log('Copied successfully')
})
</code></pre>

<h3 id="merge"><a name="user-content-merge" href="#merge" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>merge</h3>
<h5 id="missmergestreams-options"><code>miss.merge(streams, [options])</code></h5>
<p>Pipes streams together and destroys all of them if one of them closes. Calls <code>cb</code> with <code>(error)</code> if there was an error in any of the streams.</p>
<p>When using standard <code>source.pipe(destination)</code> the source will <em>not</em> be destroyed if the destination emits close or error. You are also not able to provide a callback to tell when the pipe has finished.</p>
<p><code>miss.pipe</code> does these two things for you, ensuring you handle stream errors 100% of the time (unhandled errors are probably the most common bug in most node streams code)</p>
<h4 id="original-module_1"><a name="user-content-original-module_1" href="#original-module_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.merge</code> is provided by <a href="https://github.com/emilbayes/multi-duplex-stream"><code>require('multi-duplex-stream')</code></a></p>
<h4 id="example_1"><a name="user-content-example_1" href="#example_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">// lets do a simple file copy
var fs = require('fs')

var read = fs.createReadStream('./original.zip')
var write = fs.createWriteStream('./copy.zip')

// use miss.pipe instead of read.pipe(write)
miss.pipe(read, write, function (err) {
  if (err) return console.error('Copy error!', err)
  console.log('Copied successfully')
})
</code></pre>

<h3 id="condition"><a name="user-content-condition" href="#condition" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>condition</h3>
<h5 id="missconditioncondition-stream-elsestream"><code>miss.condition(condition, stream, [elseStream])</code></h5>
<p>Pipes streams together and destroys all of them if one of them closes. Calls <code>cb</code> with <code>(error)</code> if there was an error in any of the streams.</p>
<p>When using standard <code>source.pipe(destination)</code> the source will <em>not</em> be destroyed if the destination emits close or error. You are also not able to provide a callback to tell when the pipe has finished.</p>
<p><code>miss.pipe</code> does these two things for you, ensuring you handle stream errors 100% of the time (unhandled errors are probably the most common bug in most node streams code)</p>
<h4 id="original-module_2"><a name="user-content-original-module_2" href="#original-module_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.condition</code> is provided by <a href="https://github.com/robrich/ternary-stream"><code>require('ternary-stream')</code></a></p>
<h4 id="example_2"><a name="user-content-example_2" href="#example_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">// lets do a simple file copy
var fs = require('fs')

var read = fs.createReadStream('./original.zip')
var write = fs.createWriteStream('./copy.zip')

// use miss.pipe instead of read.pipe(write)
miss.pipe(read, write, function (err) {
  if (err) return console.error('Copy error!', err)
  console.log('Copied successfully')
})
</code></pre>

<h3 id="each"><a name="user-content-each" href="#each" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>each</h3>
<h5 id="misseachstream-each-done"><code>miss.each(stream, each, [done])</code></h5>
<p>Iterate the data in <code>stream</code> one chunk at a time. Your <code>each</code> function will be called with <code>(data, next)</code> where data is a data chunk and next is a callback. Call <code>next</code> when you are ready to consume the next chunk.</p>
<p>Optionally you can call <code>next</code> with an error to destroy the stream. You can also pass the optional third argument, <code>done</code>, which is a function that will be called with <code>(err)</code> when the stream ends. The <code>err</code> argument will be populated with an error if the stream emitted an error.</p>
<h4 id="original-module_3"><a name="user-content-original-module_3" href="#original-module_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.each</code> is provided by <a href="https://npmjs.org/stream-each"><code>require('stream-each')</code></a></p>
<h4 id="example_3"><a name="user-content-example_3" href="#example_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var fs = require('fs')
var split = require('split2')

var newLineSeparatedNumbers = fs.createReadStream('numbers.txt')

var pipeline = miss.pipeline(newLineSeparatedNumbers, split())
var each = miss.each(pipeline, eachLine, done)
var sum = 0

function eachLine (line, next) {
  sum += parseInt(line.toString())
  next()
}

function done (err) {
  if (err) throw err
  console.log('sum is', sum)
}
</code></pre>

<h3 id="map"><a name="user-content-map" href="#map" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>map</h3>
<h5 id="missmapmapper"><code>miss.map(mapper)</code></h5>
<p>Builds a pipeline from all the transform streams passed in as arguments by piping them together and returning a single stream object that lets you write to the first stream and read from the last stream.</p>
<p>If any of the streams in the pipeline emits an error or gets destroyed, or you destroy the stream it returns, all of the streams will be destroyed and cleaned up for you.</p>
<h4 id="original-module_4"><a name="user-content-original-module_4" href="#original-module_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.map</code> is provided by <a href="https://github.com/brycebaril/through2-map"><code>require('through2-map')</code></a></p>
<h4 id="example_4"><a name="user-content-example_4" href="#example_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var split = require('split2')

var toInt = miss.map(function (chunk) {
  return parseInt(chunk.toString());
})

// use it like any other transform stream
var fs = require('fs')

var read = fs.createReadStream('strings.txt')
var write = fs.createWriteStream('numbers.txt')

miss.pipe(read, split(), toInt, write, function (err) {
  if (err) return console.error('String processing error!', err)
  console.log('String processed successfully')
})
</code></pre>

<h3 id="filter"><a name="user-content-filter" href="#filter" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>filter</h3>
<h5 id="missfilterpredicate"><code>miss.filter(predicate)</code></h5>
<p>Builds a pipeline from all the transform streams passed in as arguments by piping them together and returning a single stream object that lets you write to the first stream and read from the last stream.</p>
<p>If any of the streams in the pipeline emits an error or gets destroyed, or you destroy the stream it returns, all of the streams will be destroyed and cleaned up for you.</p>
<h4 id="original-module_5"><a name="user-content-original-module_5" href="#original-module_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.filter</code> is provided by <a href="https://github.com/brycebaril/through2-filter"><code>require('through2-filter')</code></a></p>
<h4 id="example_5"><a name="user-content-example_5" href="#example_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var split = require('split2')

var toInt = miss.filter(function (chunk) {
  return parseInt(chunk.toString());
})

// use it like any other transform stream
var fs = require('fs')

var read = fs.createReadStream('strings.txt')
var write = fs.createWriteStream('numbers.txt')

miss.pipe(read, split(), toInt, write, function (err) {
  if (err) return console.error('String processing error!', err)
  console.log('String processed successfully')
})
</code></pre>

<h3 id="reduce"><a name="user-content-reduce" href="#reduce" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>reduce</h3>
<h5 id="missreduceaccumulator"><code>miss.reduce(accumulator)</code></h5>
<p>Builds a pipeline from all the transform streams passed in as arguments by piping them together and returning a single stream object that lets you write to the first stream and read from the last stream.</p>
<p>If any of the streams in the pipeline emits an error or gets destroyed, or you destroy the stream it returns, all of the streams will be destroyed and cleaned up for you.</p>
<h4 id="original-module_6"><a name="user-content-original-module_6" href="#original-module_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.reduce</code> is provided by <a href="https://github.com/brycebaril/through2-reduce"><code>require('through2-reduce')</code></a></p>
<h4 id="example_6"><a name="user-content-example_6" href="#example_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var split = require('split2')

var toInt = miss.map(function (chunk) {
  return parseInt(chunk.toString());
})

// use it like any other transform stream
var fs = require('fs')

var read = fs.createReadStream('strings.txt')
var write = fs.createWriteStream('numbers.txt')

miss.pipe(read, split(), toInt, write, function (err) {
  if (err) return console.error('String processing error!', err)
  console.log('String processed successfully')
})
</code></pre>

<h3 id="split"><a name="user-content-split" href="#split" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>split</h3>
<h5 id="misssplitmatcher-mapper-options"><code>miss.split([matcher, mapper, options])</code></h5>
<p>Builds a pipeline from all the transform streams passed in as arguments by piping them together and returning a single stream object that lets you write to the first stream and read from the last stream.</p>
<p>If any of the streams in the pipeline emits an error or gets destroyed, or you destroy the stream it returns, all of the streams will be destroyed and cleaned up for you.</p>
<h4 id="original-module_7"><a name="user-content-original-module_7" href="#original-module_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.split</code> is provided by <a href="https://github.com/mcollina/split2"><code>require('split2')</code></a></p>
<h4 id="example_7"><a name="user-content-example_7" href="#example_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var split = require('split2')

var toInt = miss.map(function (chunk) {
  return parseInt(chunk.toString());
})

// use it like any other transform stream
var fs = require('fs')

var read = fs.createReadStream('strings.txt')
var write = fs.createWriteStream('numbers.txt')

miss.pipe(read, split(), toInt, write, function (err) {
  if (err) return console.error('String processing error!', err)
  console.log('String processed successfully')
})
</code></pre>

<h3 id="spy"><a name="user-content-spy" href="#spy" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>spy</h3>
<h5 id="missspyspy"><code>miss.spy(spy)</code></h5>
<p>Builds a pipeline from all the transform streams passed in as arguments by piping them together and returning a single stream object that lets you write to the first stream and read from the last stream.</p>
<p>If any of the streams in the pipeline emits an error or gets destroyed, or you destroy the stream it returns, all of the streams will be destroyed and cleaned up for you.</p>
<h4 id="original-module_8"><a name="user-content-original-module_8" href="#original-module_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.spy</code> is provided by <a href="https://github.com/brycebaril/through2-spy"><code>require('through2-spy')</code></a></p>
<h4 id="example_8"><a name="user-content-example_8" href="#example_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var split = require('split2')

var toInt = miss.map(function (chunk) {
  return parseInt(chunk.toString());
})

// use it like any other transform stream
var fs = require('fs')

var read = fs.createReadStream('strings.txt')
var write = fs.createWriteStream('numbers.txt')

miss.pipe(read, split(), toInt, write, function (err) {
  if (err) return console.error('String processing error!', err)
  console.log('String processed successfully')
})
</code></pre>

<h3 id="pipeline"><a name="user-content-pipeline" href="#pipeline" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>pipeline</h3>
<h5 id="var-pipeline-misspipelinestream1-stream2-stream3"><code>var pipeline = miss.pipeline(stream1, stream2, stream3, ...)</code></h5>
<p>Builds a pipeline from all the transform streams passed in as arguments by piping them together and returning a single stream object that lets you write to the first stream and read from the last stream.</p>
<p>If any of the streams in the pipeline emits an error or gets destroyed, or you destroy the stream it returns, all of the streams will be destroyed and cleaned up for you.</p>
<h4 id="original-module_9"><a name="user-content-original-module_9" href="#original-module_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.pipeline</code> is provided by <a href="https://npmjs.org/pumpify"><code>require('pumpify')</code></a></p>
<h4 id="example_9"><a name="user-content-example_9" href="#example_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">// first create some transform streams (note: these two modules are fictional)
var imageResize = require('image-resizer-stream')({width: 400})
var pngOptimizer = require('png-optimizer-stream')({quality: 60})

// instead of doing a.pipe(b), use pipelin
var resizeAndOptimize = miss.pipeline(imageResize, pngOptimizer)
// `resizeAndOptimize` is a transform stream. when you write to it, it writes
// to `imageResize`. when you read from it, it reads from `pngOptimizer`.
// it handles piping all the streams together for you

// use it like any other transform stream
var fs = require('fs')

var read = fs.createReadStream('./image.png')
var write = fs.createWriteStream('./resized-and-optimized.png')

miss.pipe(read, resizeAndOptimize, write, function (err) {
  if (err) return console.error('Image processing error!', err)
  console.log('Image processed successfully')
})
</code></pre>

<h3 id="duplex"><a name="user-content-duplex" href="#duplex" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>duplex</h3>
<h5 id="var-duplex-missduplexwritable-readable-opts"><code>var duplex = miss.duplex([writable, readable, opts])</code></h5>
<p>Take two separate streams, a writable and a readable, and turn them into a single <a href="https://nodejs.org/api/stream.html#stream_class_stream_duplex">duplex (readable and writable) stream</a>.</p>
<p>The returned stream will emit data from the readable. When you write to it it writes to the writable.</p>
<p>You can either choose to supply the writable and the readable at the time you create the stream, or you can do it later using the <code>.setWritable</code> and <code>.setReadable</code> methods and data written to the stream in the meantime will be buffered for you.</p>
<h4 id="original-module_10"><a name="user-content-original-module_10" href="#original-module_10" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.duplex</code> is provided by <a href="https://npmjs.org/duplexify"><code>require('duplexify')</code></a></p>
<h4 id="example_10"><a name="user-content-example_10" href="#example_10" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">// lets spawn a process and take its stdout and stdin and combine them into 1 stream
var child = require('child_process')

// @- tells it to read from stdin, --data-binary sets 'raw' binary mode
var curl = child.spawn('curl -X POST --data-binary @- http://foo.com')

// duplexCurl will write to stdin and read from stdout
var duplexCurl = miss.duplex(curl.stdin, curl.stdout)
</code></pre>

<h3 id="through"><a name="user-content-through" href="#through" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>through</h3>
<h5 id="var-transformer-missthroughoptions-transformfunction-flushfunction"><code>var transformer = miss.through([options, transformFunction, flushFunction])</code></h5>
<p>Make a custom <a href="https://nodejs.org/docs/latest/api/stream.html#stream_class_stream_transform">transform stream</a>.</p>
<p>The <code>options</code> object is passed to the internal transform stream and can be used to create an <code>objectMode</code> stream (or use the shortcut <code>miss.through.obj([...])</code>)</p>
<p>The <code>transformFunction</code> is called when data is available for the writable side and has the signature <code>(chunk, encoding, cb)</code>. Within the function, add data to the readable side any number of times with <code>this.push(data)</code>. Call <code>cb()</code> to indicate processing of the <code>chunk</code> is complete. Or to easily emit a single error or chunk, call <code>cb(err, chunk)</code></p>
<p>The <code>flushFunction</code>, with signature <code>(cb)</code>, is called just before the stream is complete and should be used to wrap up stream processing.</p>
<h4 id="original-module_11"><a name="user-content-original-module_11" href="#original-module_11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.through</code> is provided by <a href="https://npmjs.org/through2"><code>require('through2')</code></a></p>
<h4 id="example_11"><a name="user-content-example_11" href="#example_11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var fs = require('fs')

var read = fs.createReadStream('./boring_lowercase.txt')
var write = fs.createWriteStream('./AWESOMECASE.TXT')

// Leaving out the options object
var uppercaser = miss.through(
  function (chunk, enc, cb) {
    cb(null, chunk.toString().toUpperCase())
  },
  function (cb) {
    cb(null, 'ONE LAST BIT OF UPPERCASE')
  }
)

miss.pipe(read, uppercaser, write, function (err) {
  if (err) return console.error('Trouble uppercasing!')
  console.log('Splendid uppercasing!')
})
</code></pre>

<h3 id="from"><a name="user-content-from" href="#from" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>from</h3>
<h5 id="missfromopts-read"><code>miss.from([opts], read)</code></h5>
<p>Make a custom <a href="https://nodejs.org/docs/latest/api/stream.html#stream_class_stream_readable">readable stream</a>.</p>
<p><code>opts</code> contains the options to pass on to the ReadableStream constructor e.g. for creating a readable object stream (or use the shortcut <code>miss.from.obj([...])</code>).</p>
<p>Returns a readable stream that calls <code>read(size, next)</code> when data is requested from the stream.</p>
<ul>
<li><code>size</code> is the recommended amount of data (in bytes) to retrieve.</li>
<li><code>next(err, chunk)</code> should be called when you&rsquo;re ready to emit more data.</li>
</ul>
<h4 id="original-module_12"><a name="user-content-original-module_12" href="#original-module_12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.from</code> is provided by <a href="https://npmjs.org/from2"><code>require('from2')</code></a></p>
<h4 id="example_12"><a name="user-content-example_12" href="#example_12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">

function fromString(string) {
  return miss.from(function(size, next) {
    // if there's no more content
    // left in the string, close the stream.
    if (string.length &lt;= 0) return next(null, null)

    // Pull in a new chunk of text,
    // removing it from the string.
    var chunk = string.slice(0, size)
    string = string.slice(size)

    // Emit &quot;chunk&quot; from the stream.
    next(null, chunk)
  })
}

// pipe &quot;hello world&quot; out
// to stdout.
fromString('hello world').pipe(process.stdout)
</code></pre>

<h3 id="fromvalue"><a name="user-content-fromvalue" href="#fromvalue" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>fromValue</h3>
<h5 id="missfromvaluevalue"><code>miss.fromValue(value)</code></h5>
<p>Make a custom <a href="https://nodejs.org/docs/latest/api/stream.html#stream_class_stream_readable">readable stream</a>.</p>
<p><code>opts</code> contains the options to pass on to the ReadableStream constructor e.g. for creating a readable object stream (or use the shortcut <code>miss.from.obj([...])</code>).</p>
<p>Returns a readable stream that calls <code>read(size, next)</code> when data is requested from the stream.</p>
<ul>
<li><code>size</code> is the recommended amount of data (in bytes) to retrieve.</li>
<li><code>next(err, chunk)</code> should be called when you&rsquo;re ready to emit more data.</li>
</ul>
<h4 id="original-module_13"><a name="user-content-original-module_13" href="#original-module_13" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.fromValue</code> is provided by <a href="https://github.com/schnittstabil/stream-from-value"><code>require('stream-from-value')</code></a></p>
<h4 id="example_13"><a name="user-content-example_13" href="#example_13" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">function fromString(string) {
  return miss.from(function(size, next) {
    // if there's no more content
    // left in the string, close the stream.
    if (string.length &lt;= 0) return next(null, null)

    // Pull in a new chunk of text,
    // removing it from the string.
    var chunk = string.slice(0, size)
    string = string.slice(size)

    // Emit &quot;chunk&quot; from the stream.
    next(null, chunk)
  })
}

// pipe &quot;hello world&quot; out
// to stdout.
fromString('hello world').pipe(process.stdout)
</code></pre>

<h3 id="fromarray"><a name="user-content-fromarray" href="#fromarray" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>fromArray</h3>
<h5 id="missfromarrayarray"><code>miss.fromArray(Array)</code></h5>
<p>Make a custom <a href="https://nodejs.org/docs/latest/api/stream.html#stream_class_stream_readable">readable stream</a>.</p>
<p><code>opts</code> contains the options to pass on to the ReadableStream constructor e.g. for creating a readable object stream (or use the shortcut <code>miss.from.obj([...])</code>).</p>
<p>Returns a readable stream that calls <code>read(size, next)</code> when data is requested from the stream.</p>
<ul>
<li><code>size</code> is the recommended amount of data (in bytes) to retrieve.</li>
<li><code>next(err, chunk)</code> should be called when you&rsquo;re ready to emit more data.</li>
</ul>
<h4 id="original-module_14"><a name="user-content-original-module_14" href="#original-module_14" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.fromArray</code> is provided by <a href="https://github.com/schnittstabil/stream-from-array"><code>require('stream-from-array')</code></a></p>
<h4 id="example_14"><a name="user-content-example_14" href="#example_14" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">

function fromString(string) {
  return miss.from(function(size, next) {
    // if there's no more content
    // left in the string, close the stream.
    if (string.length &lt;= 0) return next(null, null)

    // Pull in a new chunk of text,
    // removing it from the string.
    var chunk = string.slice(0, size)
    string = string.slice(size)

    // Emit &quot;chunk&quot; from the stream.
    next(null, chunk)
  })
}

// pipe &quot;hello world&quot; out
// to stdout.
fromString('hello world').pipe(process.stdout)
</code></pre>

<h3 id="frompromise"><a name="user-content-frompromise" href="#frompromise" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>fromPromise</h3>
<h5 id="missfrompromisepromise"><code>miss.fromPromise(promise)</code></h5>
<p>Make a custom <a href="https://nodejs.org/docs/latest/api/stream.html#stream_class_stream_readable">readable stream</a>.</p>
<p><code>opts</code> contains the options to pass on to the ReadableStream constructor e.g. for creating a readable object stream (or use the shortcut <code>miss.from.obj([...])</code>).</p>
<p>Returns a readable stream that calls <code>read(size, next)</code> when data is requested from the stream.</p>
<ul>
<li><code>size</code> is the recommended amount of data (in bytes) to retrieve.</li>
<li><code>next(err, chunk)</code> should be called when you&rsquo;re ready to emit more data.</li>
</ul>
<h4 id="original-module_15"><a name="user-content-original-module_15" href="#original-module_15" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.fromPromise</code> is provided by <a href="https://github.com/schnittstabil/stream-from-promise"><code>require('stream-from-promise')</code></a></p>
<h4 id="example_15"><a name="user-content-example_15" href="#example_15" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">

function fromString(string) {
  return miss.from(function(size, next) {
    // if there's no more content
    // left in the string, close the stream.
    if (string.length &lt;= 0) return next(null, null)

    // Pull in a new chunk of text,
    // removing it from the string.
    var chunk = string.slice(0, size)
    string = string.slice(size)

    // Emit &quot;chunk&quot; from the stream.
    next(null, chunk)
  })
}

// pipe &quot;hello world&quot; out
// to stdout.
fromString('hello world').pipe(process.stdout)
</code></pre>

<h3 id="to"><a name="user-content-to" href="#to" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>to</h3>
<h5 id="misstooptions-write-flush"><code>miss.to([options], write, [flush])</code></h5>
<p>Make a custom <a href="https://nodejs.org/docs/latest/api/stream.html#stream_class_stream_writable">writable stream</a>.</p>
<p><code>opts</code> contains the options to pass on to the WritableStream constructor e.g. for creating a readable object stream (or use the shortcut <code>miss.to.obj([...])</code>).</p>
<p>Returns a writable stream that calls <code>write(data, enc, cb)</code> when data is written to the stream.</p>
<ul>
<li><code>data</code> is the received data to write the destination.</li>
<li><code>enc</code> encoding of the piece of data received.</li>
<li><code>next(err, chunk)</code> should be called when you&rsquo;re ready to write more data, or encountered an error.</li>
</ul>
<p><code>flush(cb)</code> is called before <code>finish</code> is emitted and allows for cleanup steps to occur.</p>
<h4 id="original-module_16"><a name="user-content-original-module_16" href="#original-module_16" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.to</code> is provided by <a href="https://npmjs.org/flush-write-stream"><code>require('flush-write-stream')</code></a></p>
<h4 id="example_16"><a name="user-content-example_16" href="#example_16" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var ws = miss.to(write, flush)

ws.on('finish', function () {
  console.log('finished')
})

ws.write('hello')
ws.write('world')
ws.end()

function write (data, enc, cb) {
  // i am your normal ._write method
  console.log('writing', data.toString())
  cb()
}

function flush (cb) {
  // i am called before finish is emitted
  setTimeout(cb, 1000) // wait 1 sec
}
</code></pre>

<p>If you run the above it will produce the following output</p>
<pre><code>writing hello
writing world
(nothing happens for 1 sec)
finished
</code></pre>

<h3 id="tostring"><a name="user-content-tostring" href="#tostring" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>toString</h3>
<h5 id="misstostringstream-callback"><code>miss.toString(stream [, callback])</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_17"><a name="user-content-original-module_17" href="#original-module_17" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.toString</code> is provided by <a href="https://github.com/jasonpincin/stream-to-string"><code>require('stream-to-string')</code></a></p>
<h4 id="example_17"><a name="user-content-example_17" href="#example_17" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre>

<h3 id="toarray"><a name="user-content-toarray" href="#toarray" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>toArray</h3>
<h5 id="misstoarraystream-callbackerr-arr"><code>miss.toArray([stream], [callback(err, arr)])</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_18"><a name="user-content-original-module_18" href="#original-module_18" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.toArray</code> is provided by <a href="https://github.com/stream-utils/stream-to-array"><code>require('stream-to-array')</code></a></p>
<h4 id="example_18"><a name="user-content-example_18" href="#example_18" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre>

<h3 id="topromise"><a name="user-content-topromise" href="#topromise" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>toPromise</h3>
<h5 id="misstopromisestream"><code>miss.toPromise(stream)</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_19"><a name="user-content-original-module_19" href="#original-module_19" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.toPromise</code> is provided by <a href="https://github.com/bendrucker/stream-to-promise"><code>require('stream-to-promise')</code></a></p>
<h4 id="example_19"><a name="user-content-example_19" href="#example_19" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre>

<h3 id="concat"><a name="user-content-concat" href="#concat" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>concat</h3>
<h5 id="var-concat-missconcatcb"><code>var concat = miss.concat(cb)</code></h5>
<p>Returns a writable stream that concatenates all data written to the stream and calls a callback with the single result.</p>
<p>Calling <code>miss.concat(cb)</code> returns a writable stream. <code>cb</code> is called when the writable stream is finished, e.g. when all data is done being written to it. <code>cb</code> is called with a single argument, <code>(data)</code>, which will containe the result of concatenating all the data written to the stream.</p>
<p>Note that <code>miss.concat</code> will not handle stream errors for you. To handle errors, use <code>miss.pipe</code> or handle the <code>error</code> event manually.</p>
<h4 id="original-module_20"><a name="user-content-original-module_20" href="#original-module_20" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.concat</code> is provided by <a href="https://npmjs.org/concat-stream"><code>require('concat-stream')</code></a></p>
<h4 id="example_20"><a name="user-content-example_20" href="#example_20" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var fs = require('fs')
var concat = require('concat-stream')

var readStream = fs.createReadStream('cat.png')
var concatStream = concat(gotPicture)

readStream.on('error', handleError)
readStream.pipe(concatStream)

function gotPicture(imageBuffer) {
  // imageBuffer is all of `cat.png` as a node.js Buffer
}

function handleError(err) {
  // handle your error appropriately here, e.g.:
  console.error(err) // print the error to STDERR
  process.exit(1) // exit program with non-zero exit code
}
</code></pre>

<h3 id="unique"><a name="user-content-unique" href="#unique" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>unique</h3>
<h5 id="missuniquestream-callback"><code>miss.unique(stream, callback)</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_21"><a name="user-content-original-module_21" href="#original-module_21" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.unique</code> is provided by <a href="https://github.com/stream-utils/unique-hash-stream"><code>require('unique-hash-stream')</code></a></p>
<h4 id="example_21"><a name="user-content-example_21" href="#example_21" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre>

<h3 id="tojson"><a name="user-content-tojson" href="#tojson" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>toJSON</h3>
<h5 id="misstojsonstream-callback"><code>miss.toJSON(stream, callback)</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_22"><a name="user-content-original-module_22" href="#original-module_22" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.toJSON</code> is provided by <a href="https://www.npmjs.com/package/stream-to-json"><code>require('stream-to-json')</code></a></p>
<h4 id="example_22"><a name="user-content-example_22" href="#example_22" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre>

<h3 id="stringify"><a name="user-content-stringify" href="#stringify" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>stringify</h3>
<h5 id="missstringifyoptions"><code>miss.stringify([options])</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_23"><a name="user-content-original-module_23" href="#original-module_23" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.stringify</code> is provided by <a href="https://github.com/stream-utils/streaming-json-stringify"><code>require('streaming-json-stringify')</code></a></p>
<h4 id="example_23"><a name="user-content-example_23" href="#example_23" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre>

<h3 id="child"><a name="user-content-child" href="#child" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>child</h3>
<h5 id="misschildcommand-args-options"><code>miss.child(command, [args], [options])</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_24"><a name="user-content-original-module_24" href="#original-module_24" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.child</code> is provided by <a href="https://github.com/stream-utils/duplex-child-process"><code>require('duplex-child-process')</code></a></p>
<h4 id="example_24"><a name="user-content-example_24" href="#example_24" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre>

<h3 id="finished"><a name="user-content-finished" href="#finished" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>finished</h3>
<h5 id="missfinishedstream-cb"><code>miss.finished(stream, cb)</code></h5>
<p>Waits for <code>stream</code> to finish or error and then calls <code>cb</code> with <code>(err)</code>. <code>cb</code> will only be called once. <code>err</code> will be null if the stream finished without error, or else it will be populated with the error from the streams <code>error</code> event.</p>
<p>This function is useful for simplifying stream handling code as it lets you handle success or error conditions in a single code path. It&rsquo;s used internally <code>miss.pipe</code>.</p>
<h4 id="original-module_25"><a name="user-content-original-module_25" href="#original-module_25" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>original module</h4>
<p><code>miss.finished</code> is provided by <a href="https://npmjs.org/end-of-stream"><code>require('end-of-stream')</code></a></p>
<h4 id="example_25"><a name="user-content-example_25" href="#example_25" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>example</h4>
<pre><code class="js">var copySource = fs.createReadStream('./movie.mp4')
var copyDest = fs.createWriteStream('./movie-copy.mp4')

copySource.pipe(copyDest)

miss.finished(copyDest, function(err) {
  if (err) return console.log('write failed', err)
  console.log('write success')
})
</code></pre></article></body></html>